# Angr输出生成机制深度分析

## 关键发现

### 1. Angr的符号执行机制

从测试结果可以看出，angr在符号执行过程中：

1. **创建符号变量**: `scanf_d_1_32` 是输入变量的符号表示
2. **生成约束**: 根据程序执行路径生成约束条件
3. **求解输出**: 在约束满足的情况下，angr会求解出具体的输出值

### 2. 约束分析

从测试程序的4个路径可以看出：

**路径1**: `Result: -2`
- 约束11: `>s 0x3` (ax > 3.75, 进入else分支)
- 约束12: `!= 0` (x < 0, 负数)
- 结果: 2 * (-1) = -2

**路径2**: `Result: 2`
- 约束11: `>s 0x3` (ax > 3.75, 进入else分支)
- 约束12: `== 0` (x >= 0, 非负数)
- 结果: 2 * 1 = 2

**路径3**: `Result: -1`
- 约束11: `<=s 0x3` (ax <= 3.75, 进入if分支)
- 约束12: `!= 0` (x < 0, 负数)
- 结果: 1 * (-1) = -1

**路径4**: `Result: 1`
- 约束11: `<=s 0x3` (ax <= 3.75, 进入if分支)
- 约束12: `== 0` (x >= 0, 非负数)
- 结果: 1 * 1 = 1

### 3. 关键洞察

**Angr如何确定输出值**：

1. **符号执行**: angr在符号执行过程中，会根据程序的控制流生成约束
2. **约束求解**: 当程序到达printf时，angr会求解当前状态下的约束
3. **具体化输出**: 在约束满足的情况下，angr会选择一个具体的值来具体化符号变量
4. **输出生成**: 使用具体化的值计算printf的参数，生成最终输出

## 回到Bess/bessi1/Eq的问题

### 路径2的约束分析

```
约束1: bvsge (_ bv3 32) ?x21  // 3 >= ?x21 (即 ax <= 3.75)
约束2: (and (distinct (_ bv0 1) ?x4247) true)  // x < 0
```

**约束含义**：
- 进入if分支 (ax <= 3.75)
- 输入为负数 (x < 0)

### 为什么输出不同

**关键问题**：虽然约束相同，但angr在具体化符号变量时可能选择了不同的值。

**可能的原因**：

1. **约束求解的不确定性**：
   - 即使约束相同，Z3求解器可能返回不同的解
   - 特别是在浮点数运算中，可能存在多个满足约束的值

2. **内存状态差异**：
   - newV和oldV有不同的内存哈希值
   - 这可能导致angr在具体化时选择不同的值

3. **浮点数精度差异**：
   - 两个程序在浮点数计算中可能有微妙的差异
   - 导致相同的约束产生不同的具体值

### 具体分析

**newV输出-1的可能原因**：
- angr在具体化时选择了某个值，使得ans计算为1
- 由于x < 0，最终返回-ans = -1

**oldV输出0的可能原因**：
- angr在具体化时选择了另一个值，使得ans计算为0
- 由于x < 0，最终返回-ans = 0

## 技术细节

### Angr的输出生成流程

1. **符号执行**: 程序在符号状态下执行
2. **约束累积**: 根据执行路径累积约束
3. **到达printf**: 程序到达printf语句
4. **约束求解**: angr求解当前约束，获得具体值
5. **输出计算**: 使用具体值计算printf参数
6. **输出捕获**: 通过posix.dumps(1)捕获输出

### 为什么约束相同但输出不同

1. **约束求解的非唯一性**: 可能存在多个满足约束的解
2. **具体化策略差异**: angr可能使用不同的具体化策略
3. **浮点数运算差异**: 微小的数值差异被放大
4. **内存状态影响**: 不同的内存状态影响具体化过程

## 结论

### Angr的输出生成机制

Angr通过以下方式生成输出：
1. **符号执行**: 在符号状态下执行程序
2. **约束求解**: 在printf时求解约束获得具体值
3. **输出计算**: 使用具体值计算输出
4. **输出捕获**: 通过posix.dumps(1)捕获

### 路径2输出差异的原因

1. **约束求解的不确定性**: 相同约束可能产生不同的解
2. **具体化策略差异**: angr可能使用不同的具体化策略
3. **浮点数精度差异**: 微小的数值差异被放大
4. **内存状态影响**: 不同的内存状态影响具体化过程

### 技术启示

这个问题揭示了：
1. **符号执行的非确定性**: 相同约束可能产生不同结果
2. **约束求解的局限性**: 特别是在浮点数运算中
3. **具体化策略的重要性**: 不同的策略可能导致不同结果

这是一个典型的符号执行在浮点数程序中的非确定性问题。
