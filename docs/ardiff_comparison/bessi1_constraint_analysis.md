# Bess/bessi1/Eq 约束疑似不等价原因分析

## 问题概述

`benchmarks/Bess/bessi1/Eq` 程序对在等价性分析中被判断为"疑似不等价-约束"，具体表现为：
- 有2个路径对存在约束不等价但程序输出相同的情况
- 有1个路径对存在约束等价但程序输出不同的情况

## 源代码差异分析

### newV.c 和 oldV.c 的关键差异

在 `else` 分支中（当 `ax >= 3.75` 时）：

**newV.c (第12行):**
```c
ans=0.2282967e-1+(3.75/ax)*(-0.2895312e-1+(3.75/ax)*(0.1787654e-1 -(3.75/ax)*0.420059e-2));//change
```

**oldV.c (第12行):**
```c
ans=0.2282967e-1+y*(-0.2895312e-1+y*(0.1787654e-1 -y*0.420059e-2));
```

**关键差异**: newV 使用 `(3.75/ax)` 而 oldV 使用 `y`，其中 `y = 3.75/ax`

## 约束分析

### 路径2约束对比

**newV路径2约束:**
```
1. bvsge (_ bv3 32) ?x21  // 3 >= ?x21 (即 ?x21 <= 3)
2. (and (distinct (_ bv0 1) ?x4247) true)  // ?x4247 != 0 (即符号位为1，x < 0)
```

**oldV路径2约束:**
```
1. bvsge (_ bv3 32) ?x21  // 3 >= ?x21 (即 ?x21 <= 3)  
2. (and (distinct (_ bv0 1) ?x4247) true)  // ?x4247 != 0 (即符号位为1，x < 0)
```

**观察**: 路径2的约束在SMT层面完全相同，但程序输出不同：
- newV: Result: -1
- oldV: Result: 0

### 路径3约束对比

**newV路径3约束:**
```
1. bvslt (_ bv3 32) ?x21  // 3 < ?x21 (即 ?x21 > 3)
2. (= (_ bv0 1) ?x4247)   // ?x4247 = 0 (即符号位为0，x >= 0)
```

**oldV路径3约束:**
```
1. bvslt (_ bv3 32) ?x21  // 3 < ?x21 (即 ?x21 > 3)
2. (= (_ bv0 1) ?x4247)   // ?x4247 = 0 (即符号位为0，x >= 0)
```

**观察**: 路径3的约束在SMT层面也完全相同，程序输出也相同：
- newV: Result: 0
- oldV: Result: 0

## 根本原因分析

### 1. 浮点数精度差异

**问题**: 虽然 `y = 3.75/ax` 在数学上等价于 `3.75/ax`，但在浮点数运算中：
- 中间变量 `y` 的存储和计算可能引入精度误差
- 直接使用 `3.75/ax` 的计算路径与先计算 `y` 再使用 `y` 的路径在数值上略有不同
- 这种差异在约束层面无法被SMT求解器识别

### 2. 编译器优化差异

**问题**: 两个版本可能被编译器优化为不同的指令序列：
- newV: 直接计算 `(3.75/ax)` 的多次使用
- oldV: 先计算 `y = 3.75/ax`，然后复用 `y`
- 不同的优化策略导致不同的中间计算结果

### 3. 约束抽象层次问题

**问题**: SMT约束只捕获了高层的逻辑条件：
- 约束只关注 `ax < 3.75` vs `ax >= 3.75` 的分支条件
- 约束只关注 `x < 0` vs `x >= 0` 的符号条件
- 约束无法捕获浮点数运算的中间精度差异

### 4. 内存哈希差异

**观察**: 即使约束相同，内存哈希也不同：
- newV路径2: 5219031828561863353
- oldV路径2: 6120431501241490510
- newV路径3: 2145699305703781870  
- oldV路径3: -2269849776565954605

这表明在符号执行过程中，两个程序的状态在内存层面确实存在差异。

## 技术细节

### 约束等价性判断的局限性

1. **SMT求解器层面**: 约束在逻辑上等价
2. **程序执行层面**: 由于浮点数精度差异，实际计算结果不同
3. **符号执行层面**: 无法完全模拟浮点数运算的精度细节

### 程序输出差异的原因

路径2中 `newV` 输出 `-1` 而 `oldV` 输出 `0` 的原因：
- 在 `ax < 3.75` 且 `x < 0` 的条件下
- 两个程序在浮点数计算中产生了不同的中间结果
- 最终导致 `ans` 的值不同
- 由于 `x < 0`，最终返回 `-ans`，所以符号相反

## 结论

`Bess/bessi1/Eq` 程序对的"疑似不等价-约束"问题源于：

1. **浮点数精度差异**: 相同的数学公式在不同实现方式下产生微小但关键的数值差异
2. **约束抽象不足**: SMT约束无法捕获浮点数运算的精度细节
3. **符号执行限制**: Angr无法完全模拟浮点数运算的所有细节
4. **编译器优化影响**: 不同的代码结构导致不同的优化结果

这是一个典型的符号执行在浮点数程序等价性分析中的局限性案例，需要结合数值分析和其他验证方法来获得更准确的结果。
