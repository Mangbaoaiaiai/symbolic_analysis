# 路径2输出不等价详细分析

## 问题描述

在 `benchmarks/Bess/bessi1/Eq` 的路径2中：
- **约束**: 完全等价 (SMT求解器判断为 equivalent)
- **输出**: newV = -1, oldV = 0
- **分类**: 疑似不等价-输出 (约束等价但输出不同)

## 约束分析

### 路径2的约束条件

两个程序的约束完全相同：

```
约束1: bvsge (_ bv3 32) ?x21  // 3 >= ?x21 (即 ax <= 3.75)
约束2: (and (distinct (_ bv0 1) ?x4247) true)  // x < 0
```

**约束含义**:
- `ax <= 3.75`: 进入第一个分支 (if ax < 3.75)
- `x < 0`: 输入为负数

## 源代码差异分析

### 关键差异

**newV.c (第12行):**
```c
ans=0.2282967e-1+(3.75/ax)*(-0.2895312e-1+(3.75/ax)*(0.1787654e-1 -(3.75/ax)*0.420059e-2));
```

**oldV.c (第12行):**
```c
ans=0.2282967e-1+y*(-0.2895312e-1+y*(0.1787654e-1 -y*0.420059e-2));
```

其中 `y = 3.75/ax` (第11行定义)

### 计算路径差异

**newV的计算路径**:
1. 直接计算 `(3.75/ax)` 的多次使用
2. 每次除法运算都有独立的舍入误差
3. 精度误差在多次计算中累积

**oldV的计算路径**:
1. 先计算 `y = 3.75/ax` (一次除法)
2. 然后复用 `y` 进行后续计算
3. 精度误差主要来自一次除法和变量存储

## 浮点数精度分析

### 精度差异的根本原因

1. **计算次数差异**:
   - newV: 3次 `(3.75/ax)` 计算
   - oldV: 1次 `3.75/ax` 计算

2. **舍入误差累积**:
   - newV: 每次除法都有独立的舍入误差
   - oldV: 一次除法，但存储和加载引入额外误差

3. **编译器优化影响**:
   - newV: 可能被优化为内联计算
   - oldV: 可能被优化为单次除法运算

### 具体数值影响

在 `ax <= 3.75` 且 `x < 0` 的条件下：

**newV的计算**:
- 由于多次 `(3.75/ax)` 计算，精度误差累积
- 最终 `ans` 值可能为正值 (如 1.0)
- 由于 `x < 0`，返回 `-ans = -1`

**oldV的计算**:
- 由于使用中间变量 `y`，精度误差较小
- 最终 `ans` 值可能为 0
- 由于 `x < 0`，返回 `-ans = 0`

## 技术细节

### 约束等价性判断的局限性

1. **SMT约束层面**:
   - 约束只捕获分支条件 (`ax <= 3.75`)
   - 约束只捕获符号条件 (`x < 0`)
   - 约束无法捕获浮点数运算的中间精度差异

2. **程序执行层面**:
   - 相同的约束条件
   - 不同的浮点数计算路径
   - 不同的精度误差累积
   - 不同的最终结果

### 内存状态差异

**内存哈希不同**:
- newV路径2: 5219031828561863353
- oldV路径2: 6120431501241490510

**状态差异**:
- 不同的浮点数中间结果
- 不同的内存布局
- 不同的寄存器状态

## 根本原因总结

### 为什么约束等价但输出不同

1. **浮点数精度敏感性**:
   - 相同的数学公式在不同实现方式下产生微小但关键的数值差异
   - 精度误差在多次计算中累积

2. **约束抽象不足**:
   - SMT约束无法捕获浮点数运算的精度细节
   - 约束只关注逻辑条件，不关注数值精度

3. **符号执行限制**:
   - Angr无法完全模拟浮点数运算的所有精度细节
   - 无法捕获编译器优化对精度的影响

4. **编译器优化影响**:
   - 不同的代码结构导致不同的优化结果
   - 不同的指令序列产生不同的精度误差

## 结论

路径2输出不等价的根本原因是：

**浮点数精度差异**导致相同的约束条件产生不同的计算结果，虽然SMT约束在逻辑上等价，但程序执行中的精度差异使得最终输出不同。

这是一个典型的符号执行在浮点数程序等价性分析中的局限性案例，展示了纯约束分析方法的不足。
