# ModDiff/Eq/LoopMult10 程序路径分析

## 程序逻辑分析

### newV.c 逻辑
```c
if (x>=9 && x<12){
    int c=0;
    for (int i=1;i<=x;++i)  // 循环x次
        c+=10;
    return c;
}
return 0;
```

### oldV.c 逻辑
```c
if (x>=9 && x<12){
    int c=0;
    for (int i=1;i<=10;++i)  // 固定循环10次
        c+=x;
    return c;
}
return 0;
```

## 理论路径分析

### 条件分析
- 条件: `x>=9 && x<12`
- 可能的x值: 9, 10, 11
- 边界情况: x<9, x>=12

### 理论路径数量
**应该有5条路径**:
1. x < 9 → return 0
2. x = 9 → 进入循环
3. x = 10 → 进入循环  
4. x = 11 → 进入循环
5. x >= 12 → return 0

## 实际符号执行结果

### newV 路径 (5条)
- **路径1**: x >= 8 → Result: 0 (x < 9的情况)
- **路径2**: x < 8 && x < 11 → Result: 0 (x < 9的情况)
- **路径3**: x < 8 && x >= 11 && x <= 9 → Result: 90 (x = 9)
- **路径4**: x < 8 && x >= 11 && x <= 10 → Result: 100 (x = 10)
- **路径5**: x < 8 && x >= 11 && x <= 11 → Result: 110 (x = 11)

### oldV 路径 (3条)
- **路径1**: x >= 8 → Result: 0 (x < 9的情况)
- **路径2**: x < 8 && x < 11 → Result: 0 (x < 9的情况)
- **路径3**: x < 8 && x >= 11 → Result: 90 (x = 9, 10, 11都返回90)

## 关键发现

### 1. 路径数量差异
- **newV**: 5条路径 (正确)
- **oldV**: 3条路径 (不完整)

### 2. 路径合并问题
**oldV的路径3合并了多个情况**:
- x = 9: 循环10次，每次加9 → 90
- x = 10: 循环10次，每次加10 → 100  
- x = 11: 循环10次，每次加11 → 110

但符号执行只生成了1条路径，输出90。

### 3. 约束分析

**newV约束特点**:
- 路径3-5包含详细的循环约束
- 每个循环迭代都有对应的约束
- 能够区分不同的x值

**oldV约束特点**:
- 约束相对简单
- 没有详细的循环约束
- 无法区分x=9,10,11的情况

## 问题分析

### 为什么oldV只有3条路径？

1. **循环固定次数**: oldV的循环次数固定为10，不依赖于x
2. **符号执行优化**: angr可能将相似的路径合并
3. **约束简化**: 由于循环次数固定，约束被简化

### 为什么newV有5条路径？

1. **循环次数可变**: newV的循环次数依赖于x
2. **路径爆炸**: 不同的x值产生不同的路径
3. **约束复杂**: 每个循环迭代都需要约束

## 结论

### 理论路径数
**两个程序都应该有5条路径**，对应：
- x < 9: return 0
- x = 9: 进入循环
- x = 10: 进入循环
- x = 11: 进入循环  
- x >= 12: return 0

### 实际路径数
- **newV**: 5条路径 ✅ (正确)
- **oldV**: 3条路径 ❌ (不完整)

### 原因
oldV的固定循环次数导致符号执行将多个情况合并为一条路径，这是符号执行工具在处理固定循环时的常见行为。

### 等价性影响
由于路径数量不同，这两个程序在等价性分析中无法找到完全匹配的路径对，导致被判断为不等价。
