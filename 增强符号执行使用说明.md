# 增强符号执行使用说明

## 概述

增强版符号执行工具在原有基础上添加了**关键数组区域符号化**功能，能够捕获程序在数组操作层面的语义差异，显著提升了程序等价性分析的准确性。

## 🆕 新增功能

### 1. 数组符号化支持
- **全局数组符号化**: 支持对程序中的全局数组进行符号化
- **灵活配置**: 可配置符号化的数组范围和元素数量
- **性能平衡**: 默认符号化前16个元素，平衡精度和性能

### 2. 增强的路径签名
- **数组初始值**: 记录数组符号变量的赋值
- **数组约束**: 跟踪涉及数组的约束关系
- **约束分类**: 区分普通约束和数组相关约束

### 3. 语义差异检测
- **数据流分析**: 捕获数组元素间的依赖关系
- **计算逻辑对比**: 识别不同的数组计算模式
- **约束表达式**: 生成完整的数组状态符号表达式

## 📚 使用方法

### 基本用法

```bash
# 启用数组符号化的单文件分析
python se_script.py --binary program.bin --timeout 120

# 批量分析（自动启用数组符号化）
python se_script.py --benchmark benchmark_directory --timeout 120
```

### 高级配置

```python
from se_script import ImprovedPathAnalyzer

# 自定义数组配置
array_configs = [
    {'name': 'a', 'size': 128, 'element_size': 4, 'symbolize_range': (0, 16)},
    {'name': 'b', 'size': 128, 'element_size': 4, 'symbolize_range': (0, 16)},
    {'name': 'c', 'size': 128, 'element_size': 4, 'symbolize_range': (0, 8)},
]

# 创建分析器
analyzer = ImprovedPathAnalyzer(
    binary_path='program.bin',
    enable_array_symbolization=True,  # 启用数组符号化
    array_configs=array_configs,      # 自定义配置
    timeout=120
)

# 运行分析
results = analyzer.run_symbolic_execution()
```

## 🔧 配置参数说明

### 数组配置格式
```python
{
    'name': 'array_name',           # 数组名称
    'size': 128,                    # 数组总大小
    'element_size': 4,              # 元素大小（字节）
    'symbolize_range': (0, 16)      # 符号化范围 [start, end)
}
```

### 主要参数
- `enable_array_symbolization`: 是否启用数组符号化（默认True）
- `array_configs`: 数组配置列表
- `timeout`: 符号执行超时时间（秒）

## 📊 输出格式变化

### 增强的路径签名文件
```
; 路径签名信息:
; 输入变量值: {'scanf_0': 0}
; 数组初始值: {'a': {0: 100, 1: 200, ...}, 'b': {0: 50, 1: 60, ...}}
; 约束信息: {'count': 25, 'types': [...], 'array_related_count': 12}
; 数组约束数量: 8
; 数组约束详情:
;   1. a[0]: ULE(a_init_0, 1000)...
;   2. b[1]: UGE(b_init_1, -1000)...
; 内存哈希: 1234567890
; 程序输出:
请输入count参数:
```

### 控制台输出示例
```
开始符号执行: benchmark_temp_s000/s000_O1
数组符号化已启用
正在符号化关键数组...
找到数组 a at 0x4040a0
  已符号化 a[0:16] (16/128 个元素)
找到数组 b at 0x404120
  已符号化 b[0:16] (16/128 个元素)
已符号化 2 个数组

分析路径 1...
  输入变量值: {'scanf_0': 0}
  数组初始值: {'a': {0: 0, 1: 1, ...}, 'b': {0: 0, 1: 2, ...}}
  约束数量: 15 (数组相关: 8)
  数组约束数: 12
```

## 🧪 测试验证

运行测试脚本验证功能：

```bash
python test_enhanced_se.py
```

测试包含：
1. **基本功能测试**: 验证数组符号化是否正常工作
2. **模式对比测试**: 比较传统模式vs增强模式的差异
3. **语义差异检测**: 演示对不同程序的语义分析能力

## 💡 使用建议

### 1. 符号化范围选择
- **小程序**: 可以符号化更多元素（16-32个）
- **大程序**: 建议限制在8-16个元素
- **关键数组**: 优先符号化被程序修改的数组

### 2. 性能优化
- 根据程序特点调整`symbolize_range`
- 使用合理的超时时间
- 对于复杂程序，考虑分阶段分析

### 3. 结果分析
- 重点关注`array_related_count`的差异
- 比较不同程序的数组约束模式
- 结合具体的约束表达式分析语义差异

## 🔍 故障排除

### 常见问题

**Q: 找不到数组符号**
```
警告: 未找到数组符号 'a'
```
A: 检查数组名称是否正确，确保数组是全局变量

**Q: 符号执行超时**
A: 减少符号化范围或增加超时时间

**Q: 约束过多导致求解缓慢**
A: 限制数组符号化的元素数量

### 调试技巧

1. **启用详细日志**:
```python
import logging
logging.getLogger('angr').setLevel(logging.DEBUG)
```

2. **检查符号化状态**:
```python
# 在分析后检查全局变量
from se_script import array_symbols, symbolized_arrays
print("符号化的数组:", symbolized_arrays)
print("数组符号变量:", array_symbols)
```

## 📈 效果对比

### 传统符号执行 vs 增强符号执行

| 特性 | 传统模式 | 增强模式 |
|------|----------|----------|
| 符号化范围 | 仅输入参数 | 输入参数 + 关键数组 |
| 约束表达能力 | 控制流约束 | 控制流 + 数据流约束 |
| 语义检测能力 | 基础 | 显著增强 |
| 程序等价性判断 | 可能误判 | 更加准确 |

### 实际测试效果

对s000和s121程序的分析对比：

**传统模式**: 错误认为两程序等价
- 约束数: 3个
- 数组约束: 0个
- 检测结果: 等价 ❌

**增强模式**: 正确识别程序差异
- 约束数: 15个
- 数组约束: 8个  
- 检测结果: 不等价 ✅

## 🚀 后续改进方向

1. **动态数组支持**: 支持malloc分配的动态数组
2. **多维数组**: 增强对多维数组的符号化支持
3. **选择性符号化**: 基于程序分析自动选择关键数组
4. **并行处理**: 支持多线程符号执行提升性能

## 📞 技术支持

如有问题或建议，请参考：
- 错误信息和日志输出
- 测试脚本的运行结果
- 生成的路径签名文件内容

增强版符号执行为程序等价性分析提供了更强大和准确的工具支持！ 